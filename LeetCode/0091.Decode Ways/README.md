# 91. 解码方法 | Decode Ways

**题目:**

一条包含字母 A-Z 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

**示例:**

```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

## 思路

### 动态规划

**状态方程** `dp[i] = dp[i-1] + dp[i-2]` ，`dp[i]` 为到第 `i` 个字符时的解码方法总数。

判断第 `i` 个字符时分两个情况：

1. 当前数字单独表示一个字母，有 `dp[i-1]` 种情况；
2. 当前数字与前一个数字表示一个字母，有 `dp[i-2]` 种情况。

两种情况相加即得到 `dp[i]`。

**但是要考虑 `0` 的情况**，`s[i-1]` 和 `s[i]` 是否为 `0` 分为四种情况：

1. `s[i-1:i] = 00` ：解码方法数为 **0** 。
2. `s[i-1:i] = 0X` ：`X` 只能单独表示一个字母，`0` 必须和其前面的数组合（前数不为零），所以只有一种情况，且 `dp[i] = dp[i-3]` 。（原 `dp[i-2]` 应该是 `dp[i-3]`）
3. `s[i-1:i] = X0` ：`0` 只能和前面的 `X` 组合，所以，只有一种情况， `dp[i] = dp[i-2]` 。
   - `s[i-1] >= 3` 时，`0` 无法与前一数组合，无解码方法，返回 **0** 。
   - `s[i-1] <= 2` 时，`0` 能且仅能与前一数组合，`dp[i] = dp[i-2]` 。
4. `s[i-1:i] = XX` ：
   - `s[i-1:i] >= 27` 时，`s[i]` 只能单独表示一个字母，`dp[i] = dp[i-1]` 。
   - `s[i-1:i] <= 26` 时，为普通情况，`dp[i] = dp[i-1] + dp[i-2]` 。

执行时间 ***4ms*** 。([Submission Detail](https://leetcode-cn.com/submissions/detail/24450118/))

```cpp
int numDecodings(string s) {
    if (s[0] == '0')return 0;

    int *dp = new int[s.length() + 1]{ 0 };
    dp[0] = dp[1] = 1;

    for (int i = 1; i < s.length(); i++) {
        if (s[i - 1] == '0') {
            if (s[i] == '0')
                return 0;
            else
                dp[i + 1] = dp[i - 2];	// i-2 不会出界，首位就是 0 的情况已经返回
        }
        else {
            if (s[i] == '0') {
                if (s[i - 1] > '2')
                    return 0;
                else
                    dp[i + 1] = dp[i - 1];
            }
            else {
                if (s[i - 1] < '2' || (s[i - 1] == '2'&&s[i] <= '6'))
                    dp[i + 1] = dp[i] + dp[i - 1];
                else
                    dp[i + 1] = dp[i];
            }
        }
    }
    return dp[s.length()];
}
```

