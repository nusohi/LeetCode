# BM7.链表中环的入口结点

> 【中等】

**描述**

给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回 `null`。

数据范围： $n\le10000$，$1<=结点值<=10000$

要求：空间复杂度 $O(1)$，时间复杂度 $O(n)$

例如，输入`{1,2},{3,4,5}`时，对应的环形链表如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46)

可以看到环的入口结点的结点值为 3，所以返回结点值为 3 的结点。

**输入描述**：

输入分为 2 段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表

**返回值描述**：

返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。

**示例1**

```
输入：{1,2},{3,4,5}
返回值：3
说明：返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即 3    
```

**示例2**

```
输入：{1},{}
返回值："null"
说明：没有环，返回对应编程语言的空结点，后台程序会打印"null"    
```

**示例3**

```
输入：{},{2}
返回值：2
说明：环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即 2 
```

## 思路

### 思路一：用节点值来计数

利用节点值，用 `val` 记录该节点被指向的次数。需要遍历 2 次，时间 $O(2n)$.

- 遍历一遍节点值初始化置零，用快慢指针退出死循环，顺便检查是否有环，没环则立即返回 `null`；
- 再遍历一遍，每个节点的下一个节点值加一，`next->val++`，如果 `next->val == 2` 则说明 `next` 是入口，返回 `next` 即可。

```cpp
// 略
```

### 思路二：快慢指针

> 思路来自 [题解 | #链表中环的入口结点#](https://blog.nowcoder.net/n/4c6d12e823344a42a51164a127208265)

1. 我们知道，用快慢指针可以很容易判断一条链表是否存在环，快指针 fast 每次走两步，慢指针 slow 每次走一步，那么若进入环中，每次他们之间的相对距离都会 **-1**，直到两者相遇。虽然这能很快的知道是否存在环，但是它能否帮我们找到环的入口呢，答案是肯定的

2. 假设从头节点到环的入口节点的前一个节点一共有 `a` 个，环中的节点有 `b` 个，设 fast 指针走过的节点数是 `f`，slow 指针走过的节点数是 `s`，那么有以下两个结论：

   - `f = 2 * s` （即快指针走过的节点数一定是慢指针的两倍）

   - `f = s + nb `（当两者相遇时，快指针一定已经绕环走了n圈）

由上面两个等式可以得出，`f = 2nb`，`s = nb`
故可知，两指针相遇时，慢指针已经走了 `nb` 步，已知我们要走到入口节点，需要走 `a + kb` 步，而这时 `s = nb` 只要再走 `a` 即可到达入口，我们把快指针移动到头节点，然后两个指针一步一步往后走，当它们相遇时所处的位置就是入口节点

**执行时间**：***5ms*** 【[Submission Detail](https://www.nowcoder.com/profile/443580699/codeBookDetail?submissionId=400399307)】

```python
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* fast = pHead, * slow = pHead;
        while (fast != NULL && fast->next != NULL) {
            fast = fast->next->next;
            slow = slow->next;
            if (slow == fast) {
                fast = pHead;
                while (slow != fast) {
                    slow = slow->next;
                    fast = fast->next;
                }
                return fast;
            }
        }
        return NULL;
    }
};
```

